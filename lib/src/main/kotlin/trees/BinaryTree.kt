package trees

import nodes.Node

/**
 * Абстрактный класс, задающий структуру различных модификаций бинарных деревьев, которые можно создать на их основе
 * @param K тип ключа значения
 * @param T тип значения
 * @param P тип (класс) указателей на потомков данного узла (реализуют абстрактный класс Node)
 *
 * @see [nodes.Node]*/
abstract class BinaryTree <K: Comparable<K>, T, P: Node<K, T, P>> {

    /**
     * @property root корень дерева
     */
    var root: P?=null

    /**
     * Внутренний класс, реализующий интерфейс Iterator для возможности прохода по всем узлам дерева
     * При этом обход совершается следующим образом: начиная от корня итератор проходит слева на права по каждому уровню
     * (т.е. сначала корень, затем его дети, потом их дети и т.д.). Если текущий узел пустой - null - то его потомки
     * не добавляются для продолжения прохода. Таким образом по полученной строке, которую выдает итератор можно однозначно восстановить дерево
     * Пример:
     * ```
     *         8
     *        / \
     *       5   15
     *      /   / \
     *     4   10  18
     *              \
     *               20
     *
     *итератор будет обходить вершины в следующем порядке:
     *    1. 8 - корень
     *    2. 5, 15 - потомки 8 слева на право
     *    3. 4, null - потомки 5 слева на право
     *    4. 10, 18 - потомки 15 слева на право
     *    5. null, null - потомки 4 слева на право
     *    6. null, null - потомки 10 слева на право (заметим, что правого потомка 5 мы пропускаем - он null)
     *    7. null, 20 - потомки 18 слева на право
     *    8. null, null - потомки 20 слева на право (аналогично пропускаем потомков 4 и 10 - они null)
     *итого: 8, 5, 15, 4, null, 10, 18, null, null, null, null, null, 20, null, null
     *```
     */
    inner class Iterate : Iterator<K?> {
        /**
         * Очередь для последовательного хранения узлов дерева
         */
        private var array: ArrayDeque<P?> = ArrayDeque()

        /**
         * Маркер, инициализирующий заполнение очереди
         */
        private var start: Int=0

        override fun hasNext(): Boolean {
            if (start==0) {
                array.addLast(root)
                start=1
            }
            if (array.isEmpty())
                return false
            return true
        }

        override fun next(): K? {
            val t=array.removeFirst()
            if (t!=null) {
                array.addLast(t.left)
                array.addLast(t.right)
            }
            return t?.key
        }

    }

    /**
     * Метод, возвращающий новый объект класса Iterate для данного дерева
     */
    operator fun iterator(): Iterate {
        return this.Iterate()
    }

    /**
     * Метод вставки значение в дерево
     * @param key ключ, определяющий положение значения в дереве.
     * @param value значение, хранимое в узле.
     * @param root ссылка на узел, начиная с которого осуществляется вставка (для рекурсивного обхода дерева); дефолтное значение установлено в корень дерева.
     */
    abstract fun insert(key: K, value: T, root:P?=this.root)
    /**
     * Метод удаления значение из дерева
     * @param key ключ, по которому происходи поиск значения в дереве.
     * @param root ссылка на узел, в поддереве которого осуществляется поиск узла для удаления (для рекурсивного обхода дерева); дефолтное значение установлено в корень дерева.
     */

    abstract fun delete(key: K, root: P?=this.root)
    /**
     * Метод поиска значение в дереве
     * @param key ключ, по которому происходи поиск значения в дереве.
     * @param root ссылка на узел, начиная с которого осуществляется поиск (для рекурсивного обхода дерева); дефолтное значение установлено в корень дерева.
     */

    abstract fun find(key: K, root: P?=this.root): Boolean
    /**
     * Метод просмотра значения в дереве
     * @param key ключ, по которому происходи поиск значения в дереве
     * @param root ссылка на узел, начиная с которого осуществляется поиск (для рекурсивного обхода дерева); дефолтное значение установлено в корень дерева
     */
    abstract fun peek(key: K, root: P?=this.root): T?
    /**
     * Метод поиска родителя данного узла дереве
     * @param key ключ, по которому происходи поиск значения в дереве
     * @param root ссылка на узел, начиная с которого осуществляется поиск (для рекурсивного обхода дерева); дефолтное значение установлено в корень дерева
     */
    abstract fun findParent(key: K, root: P?=this.root): K?
    /**
     * Метод поиска наибольшего значение, меньшего данного в дереве (возвращает null, если элемент минимален)
     * @param root ссылка на узел, начиная с которого осуществляется поиск (для рекурсивного обхода дерева); дефолтное значение установлено в корень дерева
     */
    protected abstract fun findCeiling(root: P?=this.root): P?
    /**
     * Метод печати всех узлов дерева
     */
    fun printNodes(): String {
        var res= StringBuilder()
        for (elem in iterator())
            res.append("$elem ")
        return res.toString()
    }
}
